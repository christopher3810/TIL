
```java
public class Counter {
    int counter; 
 
    public void increment() {
        counter++;
    }
}
```

단일 스레드 환경에서는 문제가 없지만 둘 이상의 스레드가 쓰기를 할 수 있으면 일관성 없는 결과를 얻기 시작함.

```java
counter ++;
```

>[!NOTE]
>위 연산은 값을 얻고 -> 증가 시키고 -> 업데이트된 값을 다시 쓰는 세가지 연산의 조합임. \
>두 쓰레드가 동시에 값을 얻고 업데이트하려고 하면, 업데이트가 손실될 수 있음.

관리 하는 방법 중 하나는 synchronized 키워드를 사용하는 것.

```java
public class SafeCounterWithLock {
    private int counter;
 
    public synchronized void increment() {
        counter++;
    }
}
```


락을 사용하면 해결은 되나 나머지 스레드는 차단되거나 일시 중단됨.

스레드를 일시 중단하고 다시 시작하는 과정은 매우 비용이 많이 들며 시스템의 전반적인 효율성에 영향을 미침.

compare-and-swap (CAS) 연산을 통해서 보장 할 수있음.

전형적인 CAS 연산은 세 개의 피연산자를 사용.

1. 작업할 메모리 위치 (M)
2. 변수의 기존 예상 값 (A)
3. 설정해야 할 새로운 값 (B)

>[!NOTE]
>CAS 연산은 M의 값을 B로 원자적으로 업데이트하지만, M의 기존 값이 A와 일치하는 경우에만 수행, 그렇지 않으면 아무런 조치도 취하지 않음.

성공 
메모리 위치 값이 예상 값과 일치하면 새 값으로 업데이트하고 이때 원래 메모리 위치의 값이 반환됨.

실패 
메모리 위치의 값이 예상 값과 일치하지 않으면, 아무런 업데이트도 수행하지 않고, 현재 값이 그대로 반환.

이 모든 단계를 하나의 atomic 한 연산으로 처리하고 단일 머신 레벨의 작업으로 수행함.

여러 스레드가 CAS를 통해 동일한 값을 업데이트하려고 시도하면 그 중 하나가 승리하여 값을 업데이트.

**그러나 Lock의 경우와 달리 다른 스레드는 일시 중단되지** 않고 단순히 값을 업데이트하지 못했다는 알림만 받게 됨.

그러면 스레드는 추가 작업을 진행할 수 있으며 컨텍스트 전환이 완전히 방지됩니다.

또 다른 결과는 핵심 프로그램 로직이 더 복잡해진다는 것.

CAS 작업이 성공하지 못했을 때 시나리오를 처리해야 하기 때문.

성공할 때까지 반복해서 재시도할 수도 있고, 사용 사례에 따라 아무것도 하지 않고 넘어갈 수도 있음.

##### java 에서의 atomic variables 

AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference

해당 클래스에서 외부로 열어둔 주요 메서드는

`get()` - 메모리에서 값을 가져와 다른 스레드에서 변경한 내용을 볼 수 있게함.

`incrementAndGet()` - 현재 값을 원자 단위로 1씩 증가시킵니다.

`set()` - 값을 메모리에 기록하여 다른 스레드에서 변경 사항을 볼 수 있도록 합니다; _휘발성_ 변수를 쓰는 것과 같습니다.

`lazySet()` - 결국 값을 메모리에 쓰고, 후속 관련 메모리 연산으로 순서가 바뀔 수도 있음.
한 가지 사용 사례는 가비지 컬렉션을 위해 다시는 액세스하지 않을 참조를 무효화하는 것.
이 경우  null _volatile_ write를 delay 시킴으로써 더 나은 성능을 얻을 수 있습니다.

`compareAndSet()` - 섹션 3에서 설명한 것과 동일하며, 성공하면 참을 반환하고, 그렇지 않으면 거짓을 반환.