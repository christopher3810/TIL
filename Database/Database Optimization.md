
Native Query 로 충분히 service 단계에서 사용할 수 있는데
ex) Mybatis, Native Query 

왜 DB 프로시저를 사용할까?

데이터가 1만건~ 100만건 사이면 사실 암거나 편한거 써도 상관 없음

그러나 데이터가 1억건을 넘어가는 헤비한 데이터라면?

레코드가 5~10 개가 넘어가는 필드형 데이터 1억건에 관련해서

서비스가 메모리에 로드하고 있다고 가정하면 상당히 문제가됨.

그럴때는 그냥 집계 쿼리를 써서 디비와의 통신을 생각하고 데이터베이스에서 집계한 데이터를 받는 형식으로 서비스에서 처리할 수 있음.

즉

Native Query, Mybatis 를 활용한 서비스 단계에서 데이터 베이스 쿼리를 디비로 통신해서 날려서 결과를 가져오는 형식은 데이터의 절대적인 양과 서비스에서 감당할 메모리의 사이즈를 생각해봐야 함.

그게 부담되는 구조라면 데이터베이스 자체에 프로시저를 구현해서 데이터베스 단에서 집계 쿼리에 대한 결과물로서의 데이터를 반환하는 로직을 생각해봐야함.

근데 

그것만 고려해야 할까?

기본적으로 Linux 와 같은 OS 내에서는 File Description 과 같은 방식을 사용하고 있음

os 자체적으로 사용하는 메모리 맵과 process 주요정보를 기록하는 file dir 를 매핑하는것

즉 리눅스에서는 프로세스 단위로 주요 정보를 하드를 사용해서 기록하고 있음.

db 도 데이터단위로 들고 있는데 파일형식으로 주요 정보 를 들고있고 해당 정보를 통신을 하면서 전달함.

그렇기 떄문에 한번에 요청할 데이터 양에 대한 io를 생각해야함.

그리고 만약에 네트워크 상태가 좋지 않다면?

네트워크 상태가 좋지 않다면 데이터를 압축해서 전송하는게 주된 방법이 될 수있음 하지만 네트워크 가 좋은 상황이라면 데이터를 압축, 해제 하는 과정자체가 더 오래 걸리기 떄문에 좋지 않을 수 있음.

데이터베이스 최적화 라는것은 여러가지를 고려해봐야 함.

1. 하드웨어 상태 -> 데이터 처리량이 많고 자주 빈번하게 조회된다면 하드웨어 자체에 io가 많을 수 있기 때문에 ssd 와같은 걸 사용해야함.
2. 네트워크 상태 -> 제일 좋은 경우는 네트워크가 빠른 경우 그러나 늦은 경우에는 데이터를 압축하는 것을 고려해 볼 수 있음.
3. 쿼리 튜닝 -> 실질적으로 쿼리가 느릴 수 있기 때문에 쿼리 자체를 튜닝해야 할 수 도 있음.
4. 데이터베이스 프로시져 활용 -> 서비스 단에서 쿼리를 생성한뒤 전송하는게 아닌 디비단에서 집계를 끝내서 끝낸 데이터만 반환해야 할 수도 있음
5. 휘발성 정보들을 빠르게 사용하기 위해서 캐싱형 인메모리 데이버 테이스의 활용

등 데이터 베이스 최적화는 다양한 외부요인과 내부요인을 잘 파악해서 조화롭게 대처해야 한다.
