### 폐포(Closure)

> 해당 챕터는 책의 내용에 부가적인 설명이 적기 때문에 주제만 가져오고 내부 내용은 별도로 작성한다.

### 단어적 의미
---

**폐포 라는 단어는 보다 직관적이지 않기 때문에 클로저라는 단어를 사용 하겠음.**

> 확실하진 않음 일단 조사한 바로 닫혀있다는 의미가 어떻게 사용된 것인지 파악 해보겠음.

수학에서 `클로저`는 `특정 연산`하에 `닫혀 있는` 구조를 가리킴.

`닫혀 있다`는 표현은 특정 `수학적 연산` 또는 규칙을 따랐을 때 `결과가 항상 동일한` `집합 내에 존재`한다는 말입니다.

예를 들어, 두 정수의 덧셈은 정수 집합 내에서 항상 닫혀 있음.

즉, 두 정수를 더하면 결과는 항상 정수.

따라서 이 경우 정수 집합은 덧셈 연산에 대한 클로저임.

이러한 개념이 데이터베이스로 확장되었을 때, <font color="#00ffcc">주어진 집합 F에 대한 클로저는 해당 집합에 속하는 모든 원소가 특정 연산(여기서는 함수 종속성)을 만족시키는 집합 이라는 의미가 될 수있음</font>.

즉 클로저 내의 집합의 모든 원소가 함수 종속성을 따른다는 것을 의미함.

즉, 함수의 종속성에 대한 클로저는 `해당 함수 종속성을 만족하는 모든 원소를 포함하는 집합`이며, 이 집합 내에서는 `함수의 종속성이 항상 유지`됨.

즉 <font color="#00ffcc">집합 F의 함수 종속성에 대한 클로저는 F가 에 대한 함수 종속성을 따르는 모든 속성의 집합</font>


**데이터베이스에서 폐포**

>Definition. Formally, the set of all dependencies that include F as well as all dependencies that can be inferred from F is called the closure of F; it is denoted by F+.
>
>(여기서  F란 주어진 집합 set F) `F를 포함한 모든 종속성 집합`과 `F로부터 유추 되어 질 수 있는 모든 종속성 집합`을 `F의 closure 즉 폐포`라고 하며 `F+`로 표시 된다.
>
>-Elmasri, R., & Navathe, S. B. (2011). Fundamentals of database systems. Boston: Pearson/Addison-Wesley.-

데이터베이스의 맥락에서 `폐포`는 `함수 종속성을 통해 얻을 수 있는 모든 속성의 집합`을 의미.

특정 속성 집합에 대한 폐포를 구하면, 그 집합으로부터 함수 종속성을 통해 유도할 수 있는 모든 속성을 알 수 있게 됨.

>함수 종속성이 X → Y, Z 라고 한다면, X의 closure는 X, Y, Z 라고 표현될 수 있음. \
>X+ = X, Y, Z

>앞으로 정리한 글에서는 폐포 보다는 Closure, 클로저라는 단어를 사용하도록 하겠음.

### 클로저 도출 예제 
---

엔티티 R에 {A, B, C, D, E }에 아래와 같은 함수 종속이 있을 경우.

1. A->C
2. B->D
3. A,B -> E

추론할 수 있는 모든 클로저는 다음과 같음.

1. A+ = A,C
2. B+ = B,D
3. (A, B)+ = A,B,C,D,E

> (A, B)+ = A,B,C,D,E 와 같이 (A, B)+가 릴레이션 R의 전체 속성을 포함하고 있으므로 릴레이션 R의 키는 A와 B 속성이 됨. 

### 암스트롱 공리와 종속성 추론 규칙
---

>암스트롱의 공리는 함수적 종속성의 논리적 특성을 설명하는 세 가지 규칙을 제공하는 추론 체계임. \
> 이 세 가지 규칙은 `반사성`, `증가성`, 그리고 `추이성`임.

암스트롱의 공리는 복잡한 함수 종속성 집합에서 유도된 종속성을 식별하고, 이를 사용하여 데이터베이스 스키마를 설계하거나 최적화하는 데 유용.


### 기본 공리(Axioms)
---

1. **반사성(Reflexivity)**
   >Y ⊆ X 이면 X → Y \
   만약 Y가 X의 부분 집합이면, X는 Y를 결정함.

예시 :  X = {주민등록번호, 이름}, Y = {이름}일 때, Y는 X의 부분 집합이므로 X → Y가 성립.

2. **확대성(Augmentation)**
   >X → Y 이면 XZ → YZ \
   >만약 X가 Y를 결정한다면, X와 어떤 집합 Z를 합친 것은 Y와 Z를 합친 것을 결정함.

예시 : X = {주민등록번호}, Y = {이름}, Z = {생년월일}일 때,` 주민등록번호는 이름을 결정`하므로, `주민등록번호와 생년월일`은 `이름과 생년월일을 결정`.

3. **이행성(Transitivity)**
   >X → Y 이고, Y → Z 이면 X → Z \
   >만약 X가 Y를 결정하고, Y가 Z를 결정한다면, X는 Z를 결정함.

예시 : X = {주민등록번호}, Y = {이름}, Z = {핸드폰번호}일 때, `주민등록번호는 이름을 결정`하고, `이름이 핸드폰 번호를 결정`하므로, `주민등록번호는 핸드폰 번호를 결정`함.

### 보조 규칙(Secondary Rules)
---

4. **분해(Decomposition)**
   >X → YZ 이면, X → Y 이면 X → Z
   >만약 X가 Y와 Z를 결정한다면, X는 Y와 Z 각각을 결정.

예시 : X = {주민등록번호}, Y = {이름}, Z = {생년월일}일 때, 주민등록번호는 이름과 생년월일을 결정하므로, 주민등록번호는 이름과 생년월일 각각을 결정함.

5. **결합, 합집합(Union)**
   >X → Y 이고, X → Z 이면 X → YZ
   >만약 X가 Y와 Z를 각각 결정한다면, X는 Y와 Z를 결정.

예시 : X = {주민등록번호}, Y = {이름}, Z = {생년월일}일 때, 주민등록번호는 이름과 생년월일을 각각 결정하므로, 주민등록번호는 이름과 생년월일을 결정함.

6. **유사 이행성(Pseudo Transitivity)**
   >X → Y 이고, YZ → W 이면 XZ → W 성립
   >만약 X가 Y를 결정하고, Y와 Z가 W를 결정한다면, X와 Z는 W를 결정.

예시 : X = {주민등록번호}, Y = {이름}, Z = {핸드폰번호}, W = {이메일}일 때, 주민등록번호는 이름을 결정하고, 이름과 핸드폰번호는 이메일을 결정하므로, 주민등록번호와 핸드폰번호는 이메일을 결정함.

### 표
---

|공리 이름|규칙|
|---|---|
|반사성 (Reflexivity)|만약 Y가 X의 부분집합이라면, X → Y가 성립.|
|확대성 (Augmentation)|만약 X → Y가 성립하면, XZ → YZ가 성립.|
|이행성 (Transitivity)|만약 X → Y가 성립하고 Y → Z가 성립하면, X → Z가 성립.|
|분해 (Decomposition)|만약 X → YZ가 성립하면, X → Y와 X → Z가 성립.|
|결합,합집합 (Union)|만약 X → Y와 X → Z가 성립하면, X → YZ가 성립.|
|유사 이행성 (Pseudo Transitivity)|만약 X → Y가 성립하고, YZ → W가 성립하면, XZ → W가 성립.|

### 참조
---
[Armstrong's Axioms in Functional Dependency in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/armstrongs-axioms-in-functional-dependency-in-dbms/)
